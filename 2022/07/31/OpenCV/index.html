<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.0.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>OpenCV - Werty Wang</title>

  
    <meta name="description" content="imread方法imshowimwrite VideoCapture 实例化对象cap    isOpened方法    read方法：读取一帧，返回ret,frame元组    get获取参数    set设置参数    release VideoWrite 实例化对象out    write    release 绘图img &#x3D; np.zeros((512,512,3), np.uint8)">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV">
<meta property="og:url" content="http://example.com/2022/07/31/OpenCV/index.html">
<meta property="og:site_name" content="Werty Wang">
<meta property="og:description" content="imread方法imshowimwrite VideoCapture 实例化对象cap    isOpened方法    read方法：读取一帧，返回ret,frame元组    get获取参数    set设置参数    release VideoWrite 实例化对象out    write    release 绘图img &#x3D; np.zeros((512,512,3), np.uint8)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/07/31/OpenCV/opening.png">
<meta property="og:image" content="http://example.com/2022/07/31/OpenCV/closing.png">
<meta property="og:image" content="http://example.com/2022/07/31/OpenCV/gradient.png">
<meta property="og:image" content="http://example.com/2022/07/31/OpenCV/gradient.png">
<meta property="og:image" content="http://example.com/2022/07/31/OpenCV/blackhat.png">
<meta property="og:image" content="http://example.com/2022/07/31/OpenCV/Log_边缘响应.jpg">
<meta property="article:published_time" content="2022-07-30T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-05T16:00:00.000Z">
<meta property="article:author" content="Werty Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/07/31/OpenCV/opening.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">Werty Wang</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-text">鼠标交互与滑动条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%83%8F%E7%B4%A0%E4%B8%8E%E6%88%AA%E5%9B%BE"><span class="toc-text">处理像素与截图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">获取图像属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E9%80%9A%E9%81%93"><span class="toc-text">拆分通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E5%9B%BE%E5%83%8F%E2%80%94Padding"><span class="toc-text">填充图像—Padding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C"><span class="toc-text">算术操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%8A%A0"><span class="toc-text">图像相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88-Blending"><span class="toc-text">图像混合(Blending)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">性能测量与优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenCV%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-text">OpenCV的图像处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4"><span class="toc-text">颜色空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-text">几何变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="toc-text">二值化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86"><span class="toc-text">图像平滑处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%A4%84%E7%90%86"><span class="toc-text">卷积处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E5%B9%B3%E6%BB%91"><span class="toc-text">图像模糊&#x2F;平滑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86"><span class="toc-text">图像形态学处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6"><span class="toc-text">图像梯度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-text">Canny边缘检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Image-Pyramids-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94"><span class="toc-text">Image Pyramids(图像金字塔)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93"><span class="toc-text">图像轮廓</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8F%8F%E8%BF%B0"><span class="toc-text">特征检测与描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E7%89%B9%E5%BE%81"><span class="toc-text">理解特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Harris-Corner-Detection-%E5%93%88%E9%87%8C%E6%96%AF%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B"><span class="toc-text">Harris Corner Detection(哈里斯角点检测)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shi-Tomasi-Corner-Detector"><span class="toc-text">Shi-Tomasi Corner Detector()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIFT-%E5%B0%BA%E5%BA%A6%E4%B8%8D%E5%8F%98%E7%89%B9%E5%BE%81%E8%BD%AC%E6%8D%A2-Scale-invariant-feature-transform"><span class="toc-text">SIFT(尺度不变特征转换,Scale-invariant feature transform)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SURF-Speeded-Up-Robust-Features"><span class="toc-text">SURF(Speeded-Up Robust Features)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FAST"><span class="toc-text">FAST</span></a></li></ol></li></ol></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Computer-Vision/">Computer Vision</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-07-30T16:00:00.000Z">2022-07-31</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>OpenCV</span></h1>
<p>imread方法<br>imshow<br>imwrite</p>
<p>VideoCapture 实例化对象cap<br>    isOpened方法<br>    read方法：读取一帧，返回ret,frame元组<br>    get获取参数<br>    set设置参数<br>    release</p>
<p>VideoWrite 实例化对象out<br>    write<br>    release</p>
<p>绘图<br>img = np.zeros((512,512,3), np.uint8) # 创建空白图像<br>rectangle<br>circle<br>ellipse<br>polygon<br>putText</p>
<p>鼠标绘图<br>mouse event callback</p>
<pre><code>所有的可用事件：
[&#39;EVENT_FLAG_ALTKEY&#39;, &#39;EVENT_FLAG_CTRLKEY&#39;, &#39;EVENT_FLAG_LBUTTON&#39;, &#39;EVENT_FLAG_MBUTTON&#39;, &#39;EVENT_FLAG_RBUTTON&#39;, &#39;EVENT_FLAG_SHIFTKEY&#39;, &#39;EVENT_LBUTTONDBLCLK&#39;, &#39;EVENT_LBUTTONDOWN&#39;, &#39;EVENT_LBUTTONUP&#39;, &#39;EVENT_MBUTTONDBLCLK&#39;, &#39;EVENT_MBUTTONDOWN&#39;, &#39;EVENT_MBUTTONUP&#39;, &#39;EVENT_MOUSEHWHEEL&#39;, &#39;EVENT_MOUSEMOVE&#39;, &#39;EVENT_MOUSEWHEEL&#39;, &#39;EVENT_RBUTTONDBLCLK&#39;, &#39;EVENT_RBUTTONDOWN&#39;, &#39;EVENT_RBUTTONUP&#39;]
</code></pre><p>cv.setMouseCallback(‘image’,draw_circle)</p>
<p>窗口相关<br>namedWindow(name,size_param)           # 创建一个窗口实例<br>    WINDOW_AUTOSIZE：不可以用鼠标改变窗口大小<br>    WINDOW_NORMAL：可以用鼠标改变窗口大小<br>resizeWindow(width,height)          # 确定窗口的宽和高<br>imshow()<br>destroyAllWindows()</p>
<p>cvtColor函数：转换颜色格式</p>
<p>waitkey() 延时并等待按键输入</p>
<p>程序框架</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mouse_callback</span>(<span class="params">event,x,y,flags,param</span>):</span></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDBLCLK:</span><br><span class="line">        cv.circle(img,(x,y),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv.namedWindow(<span class="string">&quot;Mouse_Draw_Test&quot;</span>,cv.WINDOW_NORMAL)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;Mouse_Draw_Test&#x27;</span>,mouse_callback)</span><br><span class="line"></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;Mouse_Draw_Test&quot;</span>,img)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:        <span class="comment"># 定时刷新</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;Mouse_Draw_Test&#x27;</span>,img) </span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="鼠标交互与滑动条"><a href="#鼠标交互与滑动条" class="headerlink" title="鼠标交互与滑动条"></a>鼠标交互与滑动条</h2><h1 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="处理像素与截图"><a href="#处理像素与截图" class="headerlink" title="处理像素与截图"></a>处理像素与截图</h3><h3 id="获取图像属性"><a href="#获取图像属性" class="headerlink" title="获取图像属性"></a>获取图像属性</h3><h3 id="拆分通道"><a href="#拆分通道" class="headerlink" title="拆分通道"></a>拆分通道</h3><h3 id="填充图像—Padding"><a href="#填充图像—Padding" class="headerlink" title="填充图像—Padding"></a>填充图像—Padding</h3><h2 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h2><h3 id="图像相加"><a href="#图像相加" class="headerlink" title="图像相加"></a>图像相加</h3><h3 id="图像混合-Blending"><a href="#图像混合-Blending" class="headerlink" title="图像混合(Blending)"></a>图像混合(Blending)</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h3 id="性能测量与优化"><a href="#性能测量与优化" class="headerlink" title="性能测量与优化"></a>性能测量与优化</h3><h2 id="OpenCV的图像处理"><a href="#OpenCV的图像处理" class="headerlink" title="OpenCV的图像处理"></a>OpenCV的图像处理</h2><h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>函数：</p>
<ul>
<li>cv.COLOR_BGR2GRAY</li>
<li>cv.COLOR_BGR2HSV</li>
</ul>
<p>色彩空间 BGR与HSV</p>
<blockquote>
<p>BGR: 利用原色相混的比例来表示色彩<br>  (0,0,0)表示黑色,(255,255,255)表示白色<br>HSV: 利用不同的概念来表示色彩<br>  Hue: 色相: 表示颜色的种类，即”什么颜色”<br>  Saturation：饱和度: 表示颜色的鲜艳程度，即”深浅如何”<br>  Value: 明度: 表示颜色的亮度，即”明暗如何”</p>
</blockquote>
<p>应用：物品追踪，步骤</p>
<ul>
<li>获取一帧图像</li>
<li>从BGR转换到HSV</li>
<li>指定颜色的阈值</li>
<li>进一步处理</li>
</ul>
<p>此外，利用OpenCV进行指定颜色的HSV转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>
<h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p>OpenCV可以进行如平移，旋转，仿射，透视变换等多种处理。</p>
<p>函数：</p>
<ul>
<li><p>cv.wrapAffine</p>
<p>  2*3变换矩阵</p>
</li>
<li><p>cv.wrapPerspective</p>
<p>  3*3变换矩阵</p>
</li>
</ul>
<p>仿射变换</p>
<ul>
<li>在仿射变换中，平行的直线仍被变换为平行的直线</li>
<li>三点变换</li>
<li>矩形被变换为平行四边形的变换</li>
</ul>
<p>透视变换</p>
<ul>
<li>直线在变换后仍被保持为直线</li>
<li>四点变换</li>
<li>类似于摄像头扫描，将因为拍摄角度导致形变的纸恢复成矩形</li>
</ul>
<h3 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h3><p>OpenCV可以进行</p>
<ul>
<li><p>Simple Thresholding</p>
<p>  采用统一的阈值对图像进行操作</p>
</li>
<li><p>Adaptive Thresholding</p>
<p>  根据图像附近一个小区域的状态对图像进行二值化操作，适用于不同区域光照条件不同的图像</p>
</li>
<li><p>Otsu’s Thresholding(大津法)</p>
<p>  先前的二值化操作需要认为指定一个阈值，但Otsu方法可以自动指定这个阈值</p>
</li>
</ul>
<blockquote>
<p>THRESH_BINARY_INV：反二进制阈值化．解释：该阈值化与二进制阈值化相似，先选定一个特定的灰度值作为阈值，不过最后的设定值相反。（在8位灰度图中，例如大于阈值的设定为0，而小于该阈值的设定为255）。</p>
<p>THRESH_TRUNC：截断阈值化．解释：同样首先需要选定一个阈值，图像中大于该阈值的像素点被设定为该阈值，小于该阈值的保持不变。（例如：阈值选取为125，那小于125的阈值不改变，大于125的灰度值（230）的像素点就设定为该阈值）。<br>THRESH_TOZERO：阈值化为0．解释：先选定一个阈值，然后对图像做如下处理：1 像素点的灰度值大于该阈值的不进行任何改变；2 像素点的灰度值小于该阈值的，其灰度值全部变为0。</p>
<p>THRESH_TOZERO_INV：反阈值化为0．解释：原理类似于0阈值，但是在对图像做处理的时候相反，即：像素点的灰度值小于该阈值的不进行任何改变，而大于该阈值的部分，其灰度值全部变为0。</p>
<p>此外，特殊值THRESH_OTSU可以和上述几种情况相结合。在这种情况下，函数确定最佳阀值，使用最大类间方差（OTSU）算法，并使用它，而不是指定的阀值。该函数返回返回计算出来的最佳阀值，目前只支持8位图像。</p>
<p>此外，adaptiveThreshold是自适应阀值函数，既阀值根据适应的规则自适应确定输入。阀值的测定方法有以下几种：</p>
<ul>
<li>ADAPTIVE_THRESH_MEAN_C：阀值T(x,y) 是，(x,y)的附近 blockSize x blockSize 的平均的值减去C的值。</li>
<li>ADAPTIVE_THRESH_GAUSSIAN_C：阀值T(x,y) 是，(x,y) 的附近 blockSize x blockSize 的（使用高斯分布）加重平均的值减去C的值．从blockSize确定这高斯分布的标准偏差。</li>
</ul>
</blockquote>
<h3 id="图像平滑处理"><a href="#图像平滑处理" class="headerlink" title="图像平滑处理"></a>图像平滑处理</h3><h4 id="卷积处理"><a href="#卷积处理" class="headerlink" title="卷积处理"></a>卷积处理</h4><p>将图像视作一种信号，低通滤波有助于去除噪声，高通滤波有助于捕捉图像边缘，可以通过cv.Filter2D()函数将一个卷积核作用到图像上</p>
<h4 id="图像模糊-平滑"><a href="#图像模糊-平滑" class="headerlink" title="图像模糊/平滑"></a>图像模糊/平滑</h4><ul>
<li>均值模糊</li>
</ul>
<script type="math/tex; mode=display">K = \frac{1}{9}
\begin{bmatrix}
    1 & 1 & 1 \\
    1 & 1 & 1 \\
    1 & 1 & 1
\end{bmatrix}</script><ul>
<li><p>高斯模糊</p>
<p>  将卷积核中的1换成高斯分布中相应的权值</p>
</li>
<li><p>中位数模糊</p>
<p>  在中位数模糊中，某处的像素点被替换为卷积核范围内像素点的中位数，因此不会产生新的颜色，某处的像素总是被图像中其他部分的像素所取代，有助于处理”椒盐噪声”</p>
<blockquote>
<p>椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。椒盐噪声的成因可能是影像讯号受到突如其来的强烈干扰而产生、模数转换器或位元传输错误等。例如失效的感应器导致像素值为最小值，饱和的感应器导致像素值为最大值。</p>
</blockquote>
</li>
<li><p>双边滤波器</p>
<p>  在去除噪声的同时保持图像边缘的锐利。由于高斯模糊只会考虑像素间的位置关系，而不会考虑相近的像素间的差异，所以图像边缘被无差别的平滑掉了。双边滤波器在此基础上在此基础上通过再添加一个高斯滤波器的方式确保再原像素周围只有相近的像素才会被纳入”平滑”之中。</p>
</li>
</ul>
<h3 id="图像形态学处理"><a href="#图像形态学处理" class="headerlink" title="图像形态学处理"></a>图像形态学处理</h3><p>图像形态处理是基于图像形状的运算，通常在二值图像上进行，参考<a target="_blank" rel="noopener" href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">https://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm</a></p>
<p>OpenCV支持多种处理如：</p>
<ul>
<li><p>Erosion(腐蚀)</p>
<p>  只有这个像素周围的像素周围均为1时这个像素才会被保留为1，否则这个像素为0。</p>
<p>  通常用于小的白噪声或者将相连的物体分离</p>
</li>
<li><p>Dilation(膨胀)</p>
<p>  与腐蚀相反，腐蚀会在去除噪声的同时”削减”原图像，我们可以在腐蚀之后进行膨胀以抵消腐蚀带来的影响。</p>
</li>
<li><p>Opening(开运算)</p>
<p>  就是在腐蚀之后膨胀，用于去除”物体之外”的噪声</p>
  <div align="center">
  <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2022/07/31/OpenCV/opening.png">
  </div>

<blockquote>
<p>作用</p>
<ul>
<li>消除值高于邻近点的孤立点，达到去除图像中噪声的作用；</li>
<li>消除较小的连通域，保留较大的连通域；</li>
<li>断开较窄的狭颈，可以在两个物体纤细的连接处将它们分离；</li>
<li>不明显改变较大连通域的面积的情况下平滑连通域的连界、轮廓；</li>
</ul>
</blockquote>
</li>
<li><p>Closing(闭运算)</p>
<p>  与Opening相反，Closing先膨胀之后再腐蚀，用于去除”物体之内”的噪声</p>
  <div align="center">
  <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2022/07/31/OpenCV/closing.png">
  </div>

<p>  作用</p>
<ul>
<li>消除值低于邻近点的孤立点，达到去除图像中噪声的作用；</li>
<li>连接两个邻近的连通域；</li>
<li>弥合较窄的间断和细长的沟壑；</li>
<li>去除连通域内的小型空洞；</li>
<li>和开运算一样也能够平滑物体的轮廓；</li>
</ul>
</li>
</ul>
<ul>
<li><p>Morphological Gradient</p>
<p>  腐蚀与膨胀之差，类似于获取图像的边缘</p>
  <div align="center">
  <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2022/07/31/OpenCV/gradient.png">
  </div>
</li>
<li><p>Top Hat(顶帽操作)</p>
<p>  原图像与开运算后的图像的差</p>
  <div align="center">
  <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2022/07/31/OpenCV/gradient.png">
  </div>

<p>  作用</p>
<ul>
<li>把值高于邻近点的孤立点或斑块分离出来。</li>
<li>把较小的连通域分离出来。</li>
<li>把较窄的狭颈和两个物体的纤细连接处分离出来。</li>
</ul>
</li>
<li><p>Black Hat(黑帽操作)</p>
<p>  原图像与闭运算后的图像的差</p>
  <div align="center">
  <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2022/07/31/OpenCV/blackhat.png">
  </div>

<p>  作用</p>
<ul>
<li>把值低于邻近点的孤立点或斑块分离出来。</li>
<li>把较窄的间断和细长的沟壑显现出来；</li>
<li>把连通域内的小型空洞显现出来；</li>
</ul>
</li>
</ul>
<p>此外，获取形状不规则的卷积核</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Elliptical Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Cross-shaped Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h3 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h3><p># 好像有点复杂，明天再说</p>
<h3 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h3><h3 id="Image-Pyramids-图像金字塔"><a href="#Image-Pyramids-图像金字塔" class="headerlink" title="Image Pyramids(图像金字塔)"></a>Image Pyramids(图像金字塔)</h3><h3 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h3><p>轮廓是包围图像相似部分的曲线，在形状分析和物品识别中十分有用。</p>
<p>建议使用黑白图像以提高准确率，同时确保被寻找的物体是白色的，背景是黑色的。</p>
<h2 id="特征检测与描述"><a href="#特征检测与描述" class="headerlink" title="特征检测与描述"></a>特征检测与描述</h2><h3 id="理解特征"><a href="#理解特征" class="headerlink" title="理解特征"></a>理解特征</h3><p>拐点如建筑的”尖”是很好的特征，这种特征与天空或者地面相比，相对较为少见。</p>
<h3 id="Harris-Corner-Detection-哈里斯角点检测"><a href="#Harris-Corner-Detection-哈里斯角点检测" class="headerlink" title="Harris Corner Detection(哈里斯角点检测)"></a>Harris Corner Detection(哈里斯角点检测)</h3><blockquote>
<p>角点</p>
<ul>
<li>局部小窗口沿各方向移动，窗口内的像素均产生明显变化的点。</li>
<li>图像局部曲率(梯度)突变的点。</li>
<li>对于同一场景，即使视角发生变化，其角点通常具备某些稳定不变性质的特征</li>
</ul>
</blockquote>
<p>可以用数学公式表示为：</p>
<script type="math/tex; mode=display">

E(u,v) = \Sigma_{x,y} w(x,y) [ I(x+u,y+v) - I(x,y) ]</script><p>其中$w$为窗函数，可以为矩形窗或者高斯窗，$I$为该点的强度函数。寻找角点就是为了最大化$E$</p>
<p>经过一系列神奇的推导与近似，有：</p>
<script type="math/tex; mode=display">

E(u,v) \approx 

\begin{bmatrix}
    u & v
\end{bmatrix}

M

\begin{bmatrix}
    u \\ v
\end{bmatrix}</script><p>其中：</p>
<script type="math/tex; mode=display">

M = 

\Sigma_{x,y} w(x,y)

\begin{bmatrix}

    I_{x}I_{x} & I_{x}I_{y} \\
    I_{x}I_{y} & I_{y}I_{y}

\end{bmatrix}</script><p>判别的公式可以变为：</p>
<script type="math/tex; mode=display">

R = det(M) - k(trace(M))^{2}</script><ul>
<li>When |R| is small, which happens when λ1 and λ2 are small, the region is flat.</li>
<li>When R<0, which happens when λ1>&gt;λ2 or vice versa, the region is edge.</0,></li>
<li>When R is large, which happens when λ1 and λ2 are large and λ1∼λ2, the region is a corner</li>
</ul>
<h3 id="Shi-Tomasi-Corner-Detector"><a href="#Shi-Tomasi-Corner-Detector" class="headerlink" title="Shi-Tomasi Corner Detector()"></a>Shi-Tomasi Corner Detector()</h3><p>比Harris方法速度更快，与其不同的是，最后的判别式采用：</p>
<script type="math/tex; mode=display">

R = min(\lambda_1,\lambda_2)</script><p>同时使得特征更均匀，检测精度从像素级别提升到亚像素级别</p>
<h3 id="SIFT-尺度不变特征转换-Scale-invariant-feature-transform"><a href="#SIFT-尺度不变特征转换-Scale-invariant-feature-transform" class="headerlink" title="SIFT(尺度不变特征转换,Scale-invariant feature transform)"></a>SIFT(尺度不变特征转换,Scale-invariant feature transform)</h3><p>一篇很好的文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zddblog/article/details/7521424">https://blog.csdn.net/zddblog/article/details/7521424</a></p>
<p>图像有旋转和缩放两种变换，部分特征如哈里斯角对于旋转不敏感，但是对与缩放敏感，也就是说当一个角被放的许多倍时，其顶点处可能呈现圆弧状，进而不被识别为角SIFT即是为了解决这个问题。</p>
<p>SIFT 特征是基于物体上的一些局部外观的兴趣点而与影像的大小和旋转无关。对于光线、噪声、些微视角改变的容忍度也相当高。基于这些特性，它们是高度显著而且相对容易撷取，在母数庞大的特征数据库中，很容易辨识物体而且鲜有误认。使用 SIFT特征描述对于部分物体遮蔽的侦测率也相当高，甚至只需要3个以上的SIFT物体特征就足以计算出位置与方位。在现今的电脑硬件速度下和小型的特征数据库条件下，辨识速度可接近即时运算。SIFT特征的信息量大，适合在海量数据库中快速准确匹配。</p>
<p>SIFT算法在一定程度上可解决：</p>
<ul>
<li><p>目标的旋转、缩放、平移（RST）</p>
</li>
<li><p>图像仿射/投影变换（视点viewpoint）</p>
</li>
<li><p>光照影响（illumination）</p>
</li>
<li><p>目标遮挡（occlusion）</p>
</li>
<li><p>杂物场景（clutter）</p>
</li>
<li><p>噪声</p>
</li>
</ul>
<p>首先是一些预备知识：</p>
<p>尺度空间：</p>
<p><strong>Laplacian of Gaussian</strong>(高斯拉普拉斯算子,LoG):</p>
<p>首先注意到拉普拉斯算子$\Delta$可以用于图像的边缘检测，当图像较为平滑时，拉普拉斯算子的输出为0，当图像像素强度剧烈变化时：</p>
<p><div align="center">
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2022/07/31/OpenCV/Log_边缘响应.jpg">
</div><br>同时考虑到单纯的拉普拉斯算符同样会放大图像中的噪声，故在进行拉普拉斯变换之前通常进行一次高斯滤波以去除高频噪声，拉普拉斯变换与高斯滤波的结合称为LoG。</p>
<p>二维高斯卷积核为</p>
<script type="math/tex; mode=display">

    G_{\sigma} = \frac{1}{2 \pi \sigma^{2}} exp(- \frac{x^2 + y^2}{2 \sigma^2})</script><p>直接对其应用Laplace算符后可以得到</p>
<script type="math/tex; mode=display">

    LoG(x,y) = - \frac{1}{\pi \sigma^4} (1 - \frac{x^2 + y^2}{2 \sigma^2} )exp(- \frac{x^2 + y^2}{2 \sigma^2})</script><p>将其近似到离散的卷积核即可应用到图像上，同时，当$\sigma$较小时，LoG与单纯的Laplace实质上差别不明显。</p>
<p>在实际应用中,由于LoG性能较差，故采用 <strong>Difference of Gaussian</strong> (高斯差分算子,DoG)作为LoG的近似进行计算，二者的区别是DoG不是采用Laplace算子而是差分作用到高斯平滑上，这个过程在图像金字塔中相邻两层上下相减即可完成。</p>
<p>剩下的还有点小复杂，之后再说</p>
<h4 id="SURF-Speeded-Up-Robust-Features"><a href="#SURF-Speeded-Up-Robust-Features" class="headerlink" title="SURF(Speeded-Up Robust Features)"></a>SURF(Speeded-Up Robust Features)</h4><p>SIFT性能很好，但是不够快速，为此人们提出了更快速的SURF</p>
<h4 id="FAST"><a href="#FAST" class="headerlink" title="FAST"></a>FAST</h4>

<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2022/04/03/01-Verlog/">undefined<span class="note">较早</span></a><div class="line"></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="http://example.com/">@Werty Wang</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.6.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.fancybox = Object.assign("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css");
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
